"""
Vulnerability Service Layer

This module provides business logic for managing vulnerabilities,
tracking remediation, and vulnerability lifecycle in the SecureOps platform.

Author: Chukwuebuka Tobiloba Nwaizugbe
Date: 2024
"""

import hashlib
import json
from datetime import datetime, timedelta, timezone
from enum import Enum
from typing import Any, Dict, List, Optional, Set, Tuple

from sqlalchemy import and_, delete, desc, func, or_, select, update
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from ..models.alert import Alert
from ..models.pipeline import Pipeline, ScanJob
from ..models.user import User
from ..models.vulnerability import Vulnerability
from ..utils.config import settings
from ..utils.logger import get_logger

logger = get_logger(__name__)


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels."""

    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityStatus(Enum):
    """Vulnerability status values."""

    OPEN = "open"
    ACKNOWLEDGED = "acknowledged"
    RESOLVED = "resolved"
    FALSE_POSITIVE = "false_positive"
    WONT_FIX = "wont_fix"


class ScannerType(Enum):
    """Supported scanner types."""

    DEPENDENCY = "dependency"
    SECRET = "secret"
    CONTAINER = "container"
    SAST = "sast"
    DAST = "dast"
    POLICY = "policy"


class VulnerabilityService:
    """Service for managing vulnerabilities and remediation tracking."""

    def __init__(self, db: AsyncSession):
        self.db = db

    async def get_vulnerabilities(
        self,
        user_id: int,
        skip: int = 0,
        limit: int = 100,
        severity: Optional[str] = None,
        status: Optional[str] = None,
        scanner_type: Optional[str] = None,
        pipeline_id: Optional[int] = None,
        search: Optional[str] = None,
    ) -> List[Dict[str, Any]]:
        """
        Get paginated list of vulnerabilities with filtering.

        Args:
            user_id: User ID to filter vulnerabilities
            skip: Number of records to skip
            limit: Maximum number of records to return
            severity: Filter by vulnerability severity
            status: Filter by vulnerability status
            scanner_type: Filter by scanner type
            pipeline_id: Filter by pipeline ID
            search: Search term for title or description

        Returns:
            List of vulnerability data with pipeline information
        """
        try:
            # Build base query with pipeline join
            query = (
                select(Vulnerability)
                .options(
                    selectinload(Vulnerability.pipeline),
                    selectinload(Vulnerability.scan_job),
                )
                .join(Pipeline)
                .where(Pipeline.owner_id == user_id)
            )

            # Apply filters
            if severity:
                query = query.where(Vulnerability.severity == severity)
            if status:
                query = query.where(Vulnerability.status == status)
            if scanner_type:
                query = query.where(Vulnerability.scanner_type == scanner_type)
            if pipeline_id:
                query = query.where(Vulnerability.pipeline_id == pipeline_id)
            if search:
                search_term = f"%{search.lower()}%"
                query = query.where(
                    or_(
                        func.lower(Vulnerability.title).like(search_term),
                        func.lower(Vulnerability.description).like(search_term),
                        func.lower(Vulnerability.cve_id).like(search_term),
                    )
                )

            # Add ordering and pagination
            query = (
                query.order_by(
                    desc(Vulnerability.severity_order),  # Critical first
                    desc(Vulnerability.created_at),
                )
                .offset(skip)
                .limit(limit)
            )

            # Execute query
            result = await self.db.execute(query)
            vulnerabilities = result.scalars().all()

            # Build response data
            vuln_data = []
            for vuln in vulnerabilities:
                vuln_dict = {
                    "id": vuln.id,
                    "title": vuln.title,
                    "description": vuln.description,
                    "severity": vuln.severity,
                    "status": vuln.status,
                    "scanner_type": vuln.scanner_type,
                    "vulnerability_id": vuln.vulnerability_id,
                    "cve_id": vuln.cve_id,
                    "cvss_score": vuln.cvss_score,
                    "file_path": vuln.file_path,
                    "line_number": vuln.line_number,
                    "remediation": vuln.remediation,
                    "references": vuln.references or [],
                    "first_detected": vuln.first_detected,
                    "last_detected": vuln.last_detected,
                    "created_at": vuln.created_at,
                    "updated_at": vuln.updated_at,
                    "pipeline_id": vuln.pipeline_id,
                    "pipeline_name": vuln.pipeline.name if vuln.pipeline else None,
                    "scan_job_id": vuln.scan_job_id,
                    "metadata": vuln.metadata or {},
                }

                # Add scan job details if available
                if vuln.scan_job:
                    vuln_dict["scan_details"] = {
                        "scan_date": vuln.scan_job.created_at,
                        "scanner_version": (
                            vuln.scan_job.metadata.get("scanner_version")
                            if vuln.scan_job.metadata
                            else None
                        ),
                    }

                vuln_data.append(vuln_dict)

            return vuln_data

        except Exception as e:
            logger.error(f"Error getting vulnerabilities: {str(e)}")
            raise

    async def get_vulnerability_by_id(
        self, vulnerability_id: int, user_id: int
    ) -> Optional[Dict[str, Any]]:
        """
        Get specific vulnerability by ID with detailed information.

        Args:
            vulnerability_id: Vulnerability ID
            user_id: User ID for ownership verification

        Returns:
            Vulnerability data with detailed information or None if not found
        """
        try:
            query = (
                select(Vulnerability)
                .options(
                    selectinload(Vulnerability.pipeline),
                    selectinload(Vulnerability.scan_job),
                )
                .join(Pipeline)
                .where(
                    and_(
                        Vulnerability.id == vulnerability_id,
                        Pipeline.owner_id == user_id,
                    )
                )
            )

            result = await self.db.execute(query)
            vulnerability = result.scalar_one_or_none()

            if not vulnerability:
                return None

            # Get remediation history
            remediation_history = await self._get_remediation_history(vulnerability_id)

            # Get related vulnerabilities (same CVE or similar)
            related_vulns = await self._get_related_vulnerabilities(
                vulnerability, user_id
            )

            vuln_data = {
                "id": vulnerability.id,
                "title": vulnerability.title,
                "description": vulnerability.description,
                "severity": vulnerability.severity,
                "status": vulnerability.status,
                "scanner_type": vulnerability.scanner_type,
                "vulnerability_id": vulnerability.vulnerability_id,
                "cve_id": vulnerability.cve_id,
                "cvss_score": vulnerability.cvss_score,
                "cvss_vector": vulnerability.cvss_vector,
                "file_path": vulnerability.file_path,
                "line_number": vulnerability.line_number,
                "remediation": vulnerability.remediation,
                "references": vulnerability.references or [],
                "first_detected": vulnerability.first_detected,
                "last_detected": vulnerability.last_detected,
                "created_at": vulnerability.created_at,
                "updated_at": vulnerability.updated_at,
                "pipeline_id": vulnerability.pipeline_id,
                "scan_job_id": vulnerability.scan_job_id,
                "metadata": vulnerability.metadata or {},
                "remediation_history": remediation_history,
                "related_vulnerabilities": related_vulns,
            }

            # Add pipeline details
            if vulnerability.pipeline:
                vuln_data["pipeline_details"] = {
                    "name": vulnerability.pipeline.name,
                    "repository_url": vulnerability.pipeline.repository_url,
                    "branch": vulnerability.pipeline.branch,
                    "ci_cd_platform": vulnerability.pipeline.ci_cd_platform,
                }

            # Add scan job details
            if vulnerability.scan_job:
                vuln_data["scan_details"] = {
                    "scan_id": vulnerability.scan_job.id,
                    "scan_date": vulnerability.scan_job.created_at,
                    "scanner_config": vulnerability.scan_job.configuration or {},
                    "scan_status": vulnerability.scan_job.status,
                }

            return vuln_data

        except Exception as e:
            logger.error(f"Error getting vulnerability {vulnerability_id}: {str(e)}")
            raise

    async def create_vulnerability(
        self,
        title: str,
        description: str,
        severity: str,
        scanner_type: str,
        pipeline_id: int,
        scan_job_id: Optional[int] = None,
        vulnerability_id: Optional[str] = None,
        cve_id: Optional[str] = None,
        cvss_score: Optional[float] = None,
        cvss_vector: Optional[str] = None,
        file_path: Optional[str] = None,
        line_number: Optional[int] = None,
        remediation: Optional[str] = None,
        references: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Vulnerability:
        """
        Create new vulnerability record.

        Args:
            title: Vulnerability title
            description: Detailed description
            severity: Severity level
            scanner_type: Type of scanner that found this
            pipeline_id: Associated pipeline ID
            scan_job_id: Associated scan job ID (optional)
            vulnerability_id: Scanner-specific vulnerability ID
            cve_id: CVE identifier if available
            cvss_score: CVSS score if available
            cvss_vector: CVSS vector string
            file_path: Affected file path
            line_number: Affected line number
            remediation: Remediation guidance
            references: List of reference URLs
            metadata: Additional vulnerability metadata

        Returns:
            Created vulnerability object
        """
        try:
            # Check for existing vulnerability to avoid duplicates
            fingerprint = self._generate_vulnerability_fingerprint(
                title, file_path, line_number, cve_id, vulnerability_id
            )

            existing_vuln = await self._find_existing_vulnerability(
                pipeline_id, fingerprint
            )

            if existing_vuln:
                # Update last detected time for existing vulnerability
                await self._update_vulnerability_detection(existing_vuln.id)
                return existing_vuln

            # Calculate severity order for sorting
            severity_order = self._get_severity_order(severity)

            # Create new vulnerability
            vulnerability = Vulnerability(
                title=title,
                description=description,
                severity=severity,
                severity_order=severity_order,
                status=VulnerabilityStatus.OPEN.value,
                scanner_type=scanner_type,
                pipeline_id=pipeline_id,
                scan_job_id=scan_job_id,
                vulnerability_id=vulnerability_id,
                cve_id=cve_id,
                cvss_score=cvss_score,
                cvss_vector=cvss_vector,
                file_path=file_path,
                line_number=line_number,
                remediation=remediation,
                references=references,
                metadata=metadata or {},
                fingerprint=fingerprint,
                first_detected=datetime.now(timezone.utc),
                last_detected=datetime.now(timezone.utc),
                created_at=datetime.now(timezone.utc),
            )

            self.db.add(vulnerability)
            await self.db.commit()
            await self.db.refresh(vulnerability)

            # Create alert for high/critical vulnerabilities
            if severity in [
                VulnerabilitySeverity.CRITICAL.value,
                VulnerabilitySeverity.HIGH.value,
            ]:
                await self._create_vulnerability_alert(vulnerability)

            logger.info(
                f"Created vulnerability {vulnerability.id} in pipeline {pipeline_id}"
            )
            return vulnerability

        except Exception as e:
            await self.db.rollback()
            logger.error(f"Error creating vulnerability: {str(e)}")
            raise

    async def update_vulnerability_status(
        self,
        vulnerability_id: int,
        status: str,
        user_id: int,
        notes: Optional[str] = None,
    ) -> Dict[str, Any]:
        """
        Update vulnerability status.

        Args:
            vulnerability_id: Vulnerability ID to update
            status: New status value
            user_id: User ID making the update
            notes: Optional status change notes

        Returns:
            Updated vulnerability data
        """
        try:
            # Validate status
            if status not in [s.value for s in VulnerabilityStatus]:
                raise ValueError(f"Invalid status: {status}")

            # Get current vulnerability
            vulnerability = await self.get_vulnerability_by_id(
                vulnerability_id, user_id
            )
            if not vulnerability:
                raise ValueError("Vulnerability not found")

            # Update vulnerability
            update_data = {"status": status, "updated_at": datetime.now(timezone.utc)}

            # Add resolution timestamp for resolved status
            if status == VulnerabilityStatus.RESOLVED.value:
                update_data["resolved_at"] = datetime.now(timezone.utc)
                update_data["resolved_by"] = user_id

            # Update metadata with status change history
            metadata = vulnerability.get("metadata", {})
            if "status_history" not in metadata:
                metadata["status_history"] = []

            metadata["status_history"].append(
                {
                    "from_status": vulnerability["status"],
                    "to_status": status,
                    "changed_by": user_id,
                    "changed_at": datetime.now(timezone.utc).isoformat(),
                    "notes": notes,
                }
            )
            update_data["metadata"] = metadata

            # Execute update
            query = (
                update(Vulnerability)
                .where(Vulnerability.id == vulnerability_id)
                .values(update_data)
            )
            await self.db.execute(query)
            await self.db.commit()

            logger.info(f"Updated vulnerability {vulnerability_id} status to {status}")
            # Audit log: vulnerability status change
            logger.info(
                f"Vulnerability status changed: vulnerability_id={vulnerability_id}, status={status}",
                extra={
                    "event_type": "audit.vulnerability_status_changed",
                    "vulnerability_id": vulnerability_id,
                    "status": status,
                    "user_id": user_id,
                },
            )

            # Return updated vulnerability
            return await self.get_vulnerability_by_id(vulnerability_id, user_id)

        except Exception as e:
            await self.db.rollback()
            logger.error(f"Error updating vulnerability status: {str(e)}")
            raise

    async def bulk_update_vulnerabilities(
        self, vulnerability_ids: List[int], updates: Dict[str, Any], user_id: int
    ) -> Dict[str, Any]:
        """
        Perform bulk update on multiple vulnerabilities.

        Args:
            vulnerability_ids: List of vulnerability IDs to update
            updates: Dictionary of field updates
            user_id: User ID performing the update

        Returns:
            Bulk update results
        """
        try:
            # Verify all vulnerabilities belong to user
            verification_query = (
                select(func.count(Vulnerability.id))
                .join(Pipeline)
                .where(
                    and_(
                        Vulnerability.id.in_(vulnerability_ids),
                        Pipeline.owner_id == user_id,
                    )
                )
            )

            result = await self.db.execute(verification_query)
            authorized_count = result.scalar() or 0

            if authorized_count != len(vulnerability_ids):
                raise ValueError("Some vulnerabilities not found or unauthorized")

            # Prepare update data
            update_data = {"updated_at": datetime.now(timezone.utc), **updates}

            # Execute bulk update
            query = (
                update(Vulnerability)
                .where(Vulnerability.id.in_(vulnerability_ids))
                .values(update_data)
            )

            result = await self.db.execute(query)
            updated_count = result.rowcount

            await self.db.commit()

            logger.info(f"Bulk updated {updated_count} vulnerabilities")

            return {
                "updated_count": updated_count,
                "requested_count": len(vulnerability_ids),
                "success": updated_count == len(vulnerability_ids),
            }

        except Exception as e:
            await self.db.rollback()
            logger.error(f"Error in bulk vulnerability update: {str(e)}")
            raise

    async def get_vulnerability_statistics(
        self, user_id: int, pipeline_id: Optional[int] = None, days_back: int = 30
    ) -> Dict[str, Any]:
        """
        Get comprehensive vulnerability statistics.

        Args:
            user_id: User ID
            pipeline_id: Optional pipeline filter
            days_back: Number of days to include in trends

        Returns:
            Vulnerability statistics and metrics
        """
        try:
            start_date = datetime.now(timezone.utc) - timedelta(days=days_back)

            # Build base query
            base_query = (
                select(Vulnerability).join(Pipeline).where(Pipeline.owner_id == user_id)
            )

            if pipeline_id:
                base_query = base_query.where(Vulnerability.pipeline_id == pipeline_id)

            # Get overall counts by severity
            severity_query = (
                select(
                    func.count(Vulnerability.id).label("count"), Vulnerability.severity
                )
                .select_from(base_query.subquery())
                .group_by(Vulnerability.severity)
            )

            severity_result = await self.db.execute(severity_query)
            severity_counts = {
                severity: count for count, severity in severity_result.fetchall()
            }

            # Get counts by status
            status_query = (
                select(
                    func.count(Vulnerability.id).label("count"), Vulnerability.status
                )
                .select_from(base_query.subquery())
                .group_by(Vulnerability.status)
            )

            status_result = await self.db.execute(status_query)
            status_counts = {
                status: count for count, status in status_result.fetchall()
            }

            # Get trends by day
            trends_query = (
                select(
                    func.count(Vulnerability.id).label("count"),
                    func.date_trunc("day", Vulnerability.created_at).label("date"),
                )
                .select_from(base_query.subquery())
                .where(Vulnerability.created_at >= start_date)
                .group_by(func.date_trunc("day", Vulnerability.created_at))
                .order_by("date")
            )

            trends_result = await self.db.execute(trends_query)
            daily_trends = {
                date.strftime("%Y-%m-%d"): count
                for count, date in trends_result.fetchall()
            }

            # Get scanner type distribution
            scanner_query = (
                select(
                    func.count(Vulnerability.id).label("count"),
                    Vulnerability.scanner_type,
                )
                .select_from(base_query.subquery())
                .group_by(Vulnerability.scanner_type)
            )

            scanner_result = await self.db.execute(scanner_query)
            scanner_distribution = {
                scanner: count for count, scanner in scanner_result.fetchall()
            }

            # Get top vulnerable files
            files_query = (
                select(
                    func.count(Vulnerability.id).label("count"), Vulnerability.file_path
                )
                .select_from(base_query.subquery())
                .where(Vulnerability.file_path.isnot(None))
                .group_by(Vulnerability.file_path)
                .order_by(desc("count"))
                .limit(10)
            )

            files_result = await self.db.execute(files_query)
            top_files = [
                {"file_path": file_path, "vulnerability_count": count}
                for count, file_path in files_result.fetchall()
            ]

            # Calculate resolution metrics
            total_vulns = sum(status_counts.values())
            resolved_vulns = status_counts.get("resolved", 0)
            open_vulns = status_counts.get("open", 0)

            resolution_rate = (
                (resolved_vulns / total_vulns * 100) if total_vulns > 0 else 0
            )

            # Get average resolution time
            avg_resolution_query = (
                select(
                    func.avg(
                        func.extract(
                            "epoch",
                            Vulnerability.resolved_at - Vulnerability.first_detected,
                        )
                    ).label("avg_resolution_time")
                )
                .select_from(base_query.subquery())
                .where(Vulnerability.resolved_at.isnot(None))
            )

            avg_resolution_result = await self.db.execute(avg_resolution_query)
            avg_resolution_seconds = avg_resolution_result.scalar() or 0
            avg_resolution_hours = (
                avg_resolution_seconds / 3600 if avg_resolution_seconds > 0 else 0
            )

            return {
                "total_vulnerabilities": total_vulns,
                "severity_distribution": severity_counts,
                "status_distribution": status_counts,
                "scanner_distribution": scanner_distribution,
                "daily_trends": daily_trends,
                "top_vulnerable_files": top_files,
                "metrics": {
                    "resolution_rate": round(resolution_rate, 2),
                    "avg_resolution_time_hours": round(avg_resolution_hours, 2),
                    "open_vulnerabilities": open_vulns,
                    "critical_vulnerabilities": severity_counts.get("critical", 0),
                    "high_vulnerabilities": severity_counts.get("high", 0),
                },
                "period_days": days_back,
                "generated_at": datetime.now(timezone.utc).isoformat(),
            }

        except Exception as e:
            logger.error(f"Error getting vulnerability statistics: {str(e)}")
            raise

    async def get_remediation_recommendations(
        self, user_id: int, vulnerability_ids: Optional[List[int]] = None
    ) -> List[Dict[str, Any]]:
        """
        Get AI-powered remediation recommendations for vulnerabilities.

        Args:
            user_id: User ID
            vulnerability_ids: Optional specific vulnerability IDs

        Returns:
            List of remediation recommendations
        """
        try:
            # Build query for vulnerabilities needing remediation
            query = (
                select(Vulnerability)
                .options(selectinload(Vulnerability.pipeline))
                .join(Pipeline)
                .where(
                    and_(
                        Pipeline.owner_id == user_id,
                        Vulnerability.status.in_(["open", "acknowledged"]),
                    )
                )
            )

            if vulnerability_ids:
                query = query.where(Vulnerability.id.in_(vulnerability_ids))
            else:
                # Focus on critical and high severity vulnerabilities
                query = query.where(
                    Vulnerability.severity.in_(["critical", "high"])
                ).limit(
                    20
                )  # Limit to top 20 for performance

            result = await self.db.execute(query)
            vulnerabilities = result.scalars().all()

            recommendations = []

            for vuln in vulnerabilities:
                # Generate recommendation based on vulnerability type
                recommendation = await self._generate_remediation_recommendation(vuln)
                recommendations.append(recommendation)

            # Sort by priority (critical first, then by CVSS score)
            recommendations.sort(
                key=lambda x: (-x["priority_score"], -x.get("cvss_score", 0))
            )

            return recommendations

        except Exception as e:
            logger.error(f"Error getting remediation recommendations: {str(e)}")
            raise

    async def export_vulnerabilities(
        self,
        user_id: int,
        format_type: str = "csv",
        filters: Optional[Dict[str, Any]] = None,
    ) -> str:
        """
        Export vulnerability data in specified format.

        Args:
            user_id: User ID
            format_type: Export format (csv, json, xml)
            filters: Optional filters to apply

        Returns:
            Exported data as string
        """
        try:
            # Get vulnerabilities with filters
            filters = filters or {}
            vulnerabilities = await self.get_vulnerabilities(
                user_id=user_id,
                skip=0,
                limit=10000,  # Large limit for export
                **filters,
            )

            if format_type.lower() == "csv":
                return self._export_csv(vulnerabilities)
            elif format_type.lower() == "json":
                return self._export_json(vulnerabilities)
            elif format_type.lower() == "xml":
                return self._export_xml(vulnerabilities)
            else:
                raise ValueError(f"Unsupported export format: {format_type}")

        except Exception as e:
            logger.error(f"Error exporting vulnerabilities: {str(e)}")
            raise

    # Private helper methods
    def _generate_vulnerability_fingerprint(
        self,
        title: str,
        file_path: Optional[str],
        line_number: Optional[int],
        cve_id: Optional[str],
        vulnerability_id: Optional[str],
    ) -> str:
        """Generate unique fingerprint for vulnerability deduplication."""
        components = [
            title.lower().strip(),
            file_path or "",
            str(line_number or 0),
            cve_id or "",
            vulnerability_id or "",
        ]

        fingerprint_string = "|".join(components)
        return hashlib.sha256(fingerprint_string.encode()).hexdigest()[:16]

    async def _find_existing_vulnerability(
        self, pipeline_id: int, fingerprint: str
    ) -> Optional[Vulnerability]:
        """Find existing vulnerability by fingerprint."""
        query = select(Vulnerability).where(
            and_(
                Vulnerability.pipeline_id == pipeline_id,
                Vulnerability.fingerprint == fingerprint,
                Vulnerability.status.in_(["open", "acknowledged"]),
            )
        )

        result = await self.db.execute(query)
        return result.scalar_one_or_none()

    async def _update_vulnerability_detection(self, vulnerability_id: int) -> None:
        """Update last detected timestamp for existing vulnerability."""
        query = (
            update(Vulnerability)
            .where(Vulnerability.id == vulnerability_id)
            .values(
                {
                    "last_detected": datetime.now(timezone.utc),
                    "updated_at": datetime.now(timezone.utc),
                }
            )
        )

        await self.db.execute(query)
        await self.db.commit()

    def _get_severity_order(self, severity: str) -> int:
        """Get numeric order for severity sorting."""
        severity_order = {"critical": 4, "high": 3, "medium": 2, "low": 1, "info": 0}
        return severity_order.get(severity.lower(), 0)

    async def _create_vulnerability_alert(self, vulnerability: Vulnerability) -> None:
        """Create alert for high/critical vulnerabilities."""
        try:
            from .alert_service import AlertService

            alert_service = AlertService(self.db)

            await alert_service.create_vulnerability_alert(
                vulnerability_id=vulnerability.id, pipeline_id=vulnerability.pipeline_id
            )

        except Exception as e:
            logger.error(f"Error creating vulnerability alert: {str(e)}")
            # Don't fail vulnerability creation if alert fails

    async def _get_remediation_history(
        self, vulnerability_id: int
    ) -> List[Dict[str, Any]]:
        """Get remediation history for vulnerability."""
        # This would query a remediation_history table in a full implementation
        # For now, we'll extract from metadata
        query = select(Vulnerability.metadata).where(
            Vulnerability.id == vulnerability_id
        )
        result = await self.db.execute(query)
        metadata = result.scalar() or {}

        return metadata.get("status_history", [])

    async def _get_related_vulnerabilities(
        self, vulnerability: Dict[str, Any], user_id: int, limit: int = 5
    ) -> List[Dict[str, Any]]:
        """Get vulnerabilities related to the current one."""
        related_vulns = []

        # Find by CVE ID
        if vulnerability.get("cve_id"):
            query = (
                select(Vulnerability)
                .options(selectinload(Vulnerability.pipeline))
                .join(Pipeline)
                .where(
                    and_(
                        Pipeline.owner_id == user_id,
                        Vulnerability.cve_id == vulnerability["cve_id"],
                        Vulnerability.id != vulnerability["id"],
                    )
                )
                .limit(limit)
            )

            result = await self.db.execute(query)
            cve_related = result.scalars().all()

            for vuln in cve_related:
                related_vulns.append(
                    {
                        "id": vuln.id,
                        "title": vuln.title,
                        "severity": vuln.severity,
                        "pipeline_name": vuln.pipeline.name,
                        "relationship": "same_cve",
                    }
                )

        # Find by file path
        if vulnerability.get("file_path") and len(related_vulns) < limit:
            remaining_limit = limit - len(related_vulns)

            query = (
                select(Vulnerability)
                .options(selectinload(Vulnerability.pipeline))
                .join(Pipeline)
                .where(
                    and_(
                        Pipeline.owner_id == user_id,
                        Vulnerability.file_path == vulnerability["file_path"],
                        Vulnerability.id != vulnerability["id"],
                    )
                )
                .limit(remaining_limit)
            )

            result = await self.db.execute(query)
            file_related = result.scalars().all()

            for vuln in file_related:
                related_vulns.append(
                    {
                        "id": vuln.id,
                        "title": vuln.title,
                        "severity": vuln.severity,
                        "pipeline_name": vuln.pipeline.name,
                        "relationship": "same_file",
                    }
                )

        return related_vulns

    async def _generate_remediation_recommendation(
        self, vulnerability: Vulnerability
    ) -> Dict[str, Any]:
        """Generate AI-powered remediation recommendation."""
        # This would use AI/ML models in a production system
        # For now, we'll provide rule-based recommendations

        priority_score = self._calculate_priority_score(vulnerability)

        recommendation = {
            "vulnerability_id": vulnerability.id,
            "title": vulnerability.title,
            "severity": vulnerability.severity,
            "scanner_type": vulnerability.scanner_type,
            "priority_score": priority_score,
            "cvss_score": vulnerability.cvss_score,
            "file_path": vulnerability.file_path,
            "pipeline_name": (
                vulnerability.pipeline.name if vulnerability.pipeline else None
            ),
            "recommendations": [],
            "estimated_effort": "medium",
            "automation_available": False,
        }

        # Generate specific recommendations based on vulnerability type
        if vulnerability.scanner_type == "dependency":
            recommendation["recommendations"] = [
                f"Update dependency to latest version",
                f"Review breaking changes in update",
                f"Test application after update",
                f"Consider alternative package if update not available",
            ]
            recommendation["automation_available"] = True

        elif vulnerability.scanner_type == "secret":
            recommendation["recommendations"] = [
                f"Rotate exposed secret immediately",
                f"Remove secret from code history",
                f"Use environment variables or secret management",
                f"Audit access logs for potential compromise",
            ]
            recommendation["estimated_effort"] = "high"

        elif vulnerability.scanner_type == "container":
            recommendation["recommendations"] = [
                f"Update base image to latest version",
                f"Remove unnecessary packages from container",
                f"Use minimal base images",
                f"Implement security scanning in CI/CD",
            ]

        elif vulnerability.scanner_type == "sast":
            recommendation["recommendations"] = [
                f"Review and fix code security issue",
                f"Add input validation",
                f"Implement proper error handling",
                f"Add security unit tests",
            ]

        else:
            recommendation["recommendations"] = [
                f"Review vulnerability details",
                f"Apply recommended security patches",
                f"Implement security best practices",
                f"Monitor for similar issues",
            ]

        return recommendation

    def _calculate_priority_score(self, vulnerability: Vulnerability) -> float:
        """Calculate priority score for remediation ordering."""
        score = 0.0

        # Severity weight (40% of score)
        severity_weights = {
            "critical": 10.0,
            "high": 7.5,
            "medium": 5.0,
            "low": 2.5,
            "info": 1.0,
        }
        score += severity_weights.get(vulnerability.severity, 1.0) * 4.0

        # CVSS score weight (30% of score)
        if vulnerability.cvss_score:
            score += vulnerability.cvss_score * 3.0

        # Age weight (20% of score) - older vulnerabilities get higher priority
        if vulnerability.first_detected:
            age_days = (datetime.now(timezone.utc) - vulnerability.first_detected).days
            score += min(age_days / 30, 2.0) * 10.0  # Max 2 months

        # Scanner type weight (10% of score)
        scanner_weights = {
            "secret": 1.0,  # Highest priority
            "dependency": 0.8,
            "container": 0.6,
            "sast": 0.7,
            "policy": 0.4,
        }
        score += scanner_weights.get(vulnerability.scanner_type, 0.5) * 10.0

        return round(score, 2)

    def _export_csv(self, vulnerabilities: List[Dict[str, Any]]) -> str:
        """Export vulnerabilities as CSV."""
        import csv
        from io import StringIO

        output = StringIO()
        writer = csv.writer(output)

        # Write header
        headers = [
            "ID",
            "Title",
            "Severity",
            "Status",
            "Scanner",
            "CVE ID",
            "CVSS Score",
            "File Path",
            "Line Number",
            "Pipeline",
            "Created Date",
            "Last Detected",
        ]
        writer.writerow(headers)

        # Write data
        for vuln in vulnerabilities:
            writer.writerow(
                [
                    vuln.get("id", ""),
                    vuln.get("title", ""),
                    vuln.get("severity", ""),
                    vuln.get("status", ""),
                    vuln.get("scanner_type", ""),
                    vuln.get("cve_id", ""),
                    vuln.get("cvss_score", ""),
                    vuln.get("file_path", ""),
                    vuln.get("line_number", ""),
                    vuln.get("pipeline_name", ""),
                    vuln.get("created_at", ""),
                    vuln.get("last_detected", ""),
                ]
            )

        return output.getvalue()

    def _export_json(self, vulnerabilities: List[Dict[str, Any]]) -> str:
        """Export vulnerabilities as JSON."""
        return json.dumps(
            {
                "vulnerabilities": vulnerabilities,
                "exported_at": datetime.now(timezone.utc).isoformat(),
                "total_count": len(vulnerabilities),
            },
            indent=2,
            default=str,
        )

    def _export_xml(self, vulnerabilities: List[Dict[str, Any]]) -> str:
        """Export vulnerabilities as XML."""
        # Simple XML export implementation
        xml_parts = ['<?xml version="1.0" encoding="UTF-8"?>']
        xml_parts.append("<vulnerabilities>")
        xml_parts.append(
            f'<export_info exported_at="{datetime.now(timezone.utc).isoformat()}" total_count="{len(vulnerabilities)}"/>'
        )

        for vuln in vulnerabilities:
            xml_parts.append("  <vulnerability>")
            for key, value in vuln.items():
                if value is not None and not isinstance(value, (dict, list)):
                    xml_parts.append(f"    <{key}>{str(value)}</{key}>")
            xml_parts.append("  </vulnerability>")

        xml_parts.append("</vulnerabilities>")

        return "\n".join(xml_parts)
